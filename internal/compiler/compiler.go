package compiler

import (
	// "bytes"
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"text/template"

	"github.com/t1d333/refal5-tree/internal/ast"
	"github.com/t1d333/refal5-tree/internal/parser"
)

// Templates

const (
	mainFileTmplString = `
package main

import (
	"github.com/t1d333/refal5-tree/pkg/runtime"
	"fmt"
)

// Autogenerated functions
{{- range .Functions }}
	 {{ template "r5t-func" . }}
{{- end }}

// Rope with view field
var viewField *runtime.Rope

func main() {

	gofunc := &runtime.R5Function{
		Name:	 "GO", 
		Entry: true,
		Ptr:   r5tGO_,
	}
	
	viewField = runtime.InitViewField(gofunc)
	runtime.StartMainLoop(viewField)
}`

	compiledFunctionTmplString = `
func r5t{{.Name}}_ (arg *runtime.Rope) {
	{{ range .Body }}
		{{ template "r5t-sentence" . }}
	{{ end }}
  panic("Recognition failed")
}`

	compiledSentenceTmplString = `
  for i := 0; i < 1; i++ {
{{- range $name, $idxs := .VarsToIdxs }}
    /* {{ $name }}: {{- range $place := $idxs }} {{ index $place 0}} {{- end }} */
{{- end }}
    var p []int = make([]int, {{ .VarsArrSize }})
		p[0] = 1
		p[1] = arg.Len() - 1

{{- range $i, $cmd := .Commands}}
    {{ $cmd }}
{{- end}}
		fmt.Println("Successfully recognized")
    return;
  }`

	elementaryMatchCommandTmplString = `
{{ if eq .NodeType "Empty" }}
if (!runtime.R5t{{.NodeType}}(p[{{.LeftBorder}}], p[{{.RightBorder}}], arg)) {
	continue
}
{{ else }}
	{{if or (eq .NodeType "SymbolVar") (eq .NodeType "TermVar") }}
		if (!runtime.R5t{{.NodeType}}{{.Side}}({{.Idx}}, p[{{.LeftBorder}}], p[{{.RightBorder}}], arg, p)) {
			continue
		}
	{{ else }}
		if (!runtime.R5t{{.NodeType}}{{.Side}}({{.Idx}}, p[{{.LeftBorder}}], p[{{.RightBorder}}]{{if ne .NodeType "Brackets" }}, {{.Value}}{{ end }}, arg, p)) {
			continue
		}
	{{ end }}
{{ end }}
`
)

type MatchCmdSideType string

const (
	LeftMatchCmdType  MatchCmdSideType = "Left"
	RightMatchCmdType MatchCmdSideType = "Right"
)

type MatchCmdNodeType string

const (
	CharMatchCmdNodeType              MatchCmdNodeType = "Char"
	BracketsMatchCmdNodeType          MatchCmdNodeType = "Brackets"
	NumberMatchCmdNodeType            MatchCmdNodeType = "Number"
	FunctionMatchCmdNodeType          MatchCmdNodeType = "Function"
	SymbolVarMatchCmdNodeType         MatchCmdNodeType = "SymbolVar"
	TermVarMatchCmdNodeType           MatchCmdNodeType = "TermVar"
	RepeatedSymbolVarMatchCmdNodeType MatchCmdNodeType = "RepeatedSymbolVar"
	RepeatedTermVarMatchCmdNodeType   MatchCmdNodeType = "RepeatedTermVar"
	EmptyNodeType                     MatchCmdNodeType = "Empty"
)

type MatchCommandArg struct {
	NodeType    MatchCmdNodeType
	Side        MatchCmdSideType
	Idx         int
	LeftBorder  int
	RightBorder int
	Value       string
}

type CompiledProgram struct {
	Functions []CompiledFunction
}

type CompiledFunction struct {
	Name  string
	Body  []CompiledSentence
	Entry bool
}

type CompiledSentence struct {
	VarsArrSize int
	VarsToIdxs  map[string][][]int
	Commands    []string
}

type Compiler struct {
	parser               parser.Refal5Parser
	compiledProgramTmpl  *template.Template
	compiledFunctionTmpl *template.Template
	compiledSentenceTmpl *template.Template
	compiledMatchCmdTmpl *template.Template
}

func NewRefal5Compiler() *Compiler {
	mainTmpl, _ := template.New("r5t-main").Parse(mainFileTmplString)
	funcTmpl := template.Must(mainTmpl.New("r5t-func").Parse(compiledFunctionTmplString))
	sentenceTmpl := template.Must(funcTmpl.New("r5t-sentence").Parse(compiledSentenceTmplString))
	matchCmdTmpl, _ := template.New("r5t-match-cmd").Parse(elementaryMatchCommandTmplString)

	compiler := &Compiler{
		parser:               parser.NewTreeSitterRefal5Parser(),
		compiledSentenceTmpl: sentenceTmpl,
		compiledProgramTmpl:  mainTmpl,
		compiledFunctionTmpl: funcTmpl,
		compiledMatchCmdTmpl: matchCmdTmpl,
	}

	return compiler
}

func (c *Compiler) Compile(files []string, options CompilerOptions) {
	sources := [][]byte{}
	trees := []*ast.AST{}
	for _, file := range files {
		code, err := c.readFile(file)
		if err != nil {
			// TODO: wrap error
			return
		}

		sources = append(sources, code)

		for _, source := range sources {
			ast, _ := c.parser.Parse(source)
			trees = append(trees, ast)
		}

		c.Generate(trees)
	}
}

func (c *Compiler) readFile(path string) ([]byte, error) {
	file, err := os.ReadFile(filepath.Clean(path))
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", path, err)
	}

	return file, nil
}

func (c *Compiler) Generate(trees []*ast.AST) (string, error) {
	// TODO: find Go function and generate code for GO
	// TODO: generate code for another functions

	// Templates
	functions := []CompiledFunction{}

	for _, tree := range trees {
		for _, function := range tree.Functions {

			generatedBody, err := c.GenerateFunctionBodyCode(function)
			if err != nil {
				return "", fmt.Errorf(
					"failed to generate code for function %s: %w",
					function.Name,
					err,
				)
			}

			compiled := CompiledFunction{
				Name:  function.Name,
				Body:  generatedBody,
				Entry: function.Entry,
			}

			functions = append(functions, compiled)
			// compiledFuncTmpl.Execute(&buff, function)
			// for _, sentence := range function.Body {
			// }

		}

		c.compiledProgramTmpl.Execute(os.Stdout,
			CompiledProgram{
				Functions: functions,
			},
		)
	}

	// mainTmpl.Execute(os.Stdout, compiledProgram{Functions: generatedFunctions})
	return "", nil
}

func (c *Compiler) GenerateFunctionBodyCode(f *ast.FunctionNode) ([]CompiledSentence, error) {
	body := []CompiledSentence{}

	for _, sentence := range f.Body {
		// body = append(body, CompiledSentence{Value: fmt.Sprintf("  //Sentence #%d", i)})
		compiledSentence := c.GenerateSentence(sentence)

		body = append(body, compiledSentence)
	}

	return body, nil
}

type patternHole struct {
	patterns []ast.PatternNode
	borders  [][]int
}

func (c *Compiler) GenerateSentence(sentence *ast.SentenceNode) CompiledSentence {
	compiledSentence := CompiledSentence{
		VarsArrSize: 0,
		VarsToIdxs:  map[string][][]int{},
		Commands:    []string{},
	}

	patternHoles := []patternHole{{
		patterns: sentence.Lhs,
		borders:  [][]int{{0, 1}},
	}}

	cmds := []string{}
	nextBorder := 2

	for len(patternHoles) > 0 {
		hole := patternHoles[0]
		patternHoles = patternHoles[1:]
		patterns := hole.patterns

		borders := hole.borders

		for len(borders) > 0 {

			left, right := borders[0][0], borders[0][1]
			borders = borders[1:]

			cmdArg := MatchCommandArg{
				Idx:         nextBorder,
				LeftBorder:  left,
				RightBorder: right,
			}

			// TODO: check empty hole
			if len(patterns) == 0 {
				cmdArg.NodeType = EmptyNodeType
				cmd := c.generateMatchCmd(cmdArg)
				cmds = append(cmds, cmd)
				break
			}

			// TODO: check if left hole is symbol
			if charNode, ok := patterns[0].(*ast.CharactersPatternNode); ok {
				cmdArg.NodeType = CharMatchCmdNodeType
				cmdArg.Side = LeftMatchCmdType
				cmdArg.Value = fmt.Sprintf("'%c'", charNode.Value[0])
				cmd := c.generateMatchCmd(cmdArg)

				charNode.Value = charNode.Value[1:]

				if len(charNode.Value) == 0 {
					patterns = patterns[1:]
				}

				borders = append([][]int{{nextBorder, right}}, borders...)
				cmds = append(cmds, cmd)
				nextBorder += 1
				continue
			}

			// TODO: check if right hole is symbol
			if charNode, ok := patterns[len(patterns)-1].(*ast.CharactersPatternNode); ok {
				cmdArg.NodeType = CharMatchCmdNodeType
				cmdArg.Side = RightMatchCmdType
				cmdArg.Value = fmt.Sprintf("'%c'", charNode.Value[0])
				cmd := c.generateMatchCmd(cmdArg)

				charNode.Value = charNode.Value[1:]

				if len(charNode.Value) == 0 {
					patterns = patterns[:len(patterns)-1]
				}

				borders = append([][]int{{left, nextBorder}}, borders...)
				cmds = append(cmds, cmd)
				nextBorder += 1
				continue
			}

			// TODO: check if left hole is number
			if numberNode, ok := patterns[0].(*ast.NumberPatternNode); ok {
				cmdArg.NodeType = NumberMatchCmdNodeType
				cmdArg.Side = LeftMatchCmdType
				cmdArg.Value = fmt.Sprintf("%d", numberNode.Value)
				cmd := c.generateMatchCmd(cmdArg)

				patterns = patterns[1:]
				borders = append([][]int{{nextBorder, right}}, borders...)
				cmds = append(cmds, cmd)
				nextBorder += 1
				continue
			}

			// TODO: check if right hole is symbol
			if numberNode, ok := patterns[len(patterns)-1].(*ast.NumberPatternNode); ok {
				cmdArg.NodeType = NumberMatchCmdNodeType
				cmdArg.Side = RightMatchCmdType
				cmdArg.Value = fmt.Sprintf("%d", numberNode.Value)

				cmd := c.generateMatchCmd(cmdArg)

				patterns = patterns[:len(patterns)-1]
				borders = append([][]int{{left, nextBorder}}, borders...)
				cmds = append(cmds, cmd)
				nextBorder += 1
				continue
			}

			// TODO: check if left hole is bracket
			if grouped, ok := patterns[0].(*ast.GroupedPatternNode); ok {
				cmdArg.NodeType = BracketsMatchCmdNodeType
				cmdArg.Side = LeftMatchCmdType
				cmd := c.generateMatchCmd(cmdArg)

				patterns = patterns[1:]
				patternHoles = append(patternHoles, patternHole{
					patterns: grouped.Patterns,
					borders:  [][]int{{nextBorder, nextBorder + 1}},
				})
				borders = append([][]int{{nextBorder + 1, right}}, borders...)
				cmds = append(cmds, cmd)
				nextBorder += 2
				continue
			}

			// TODO: check if right hole is bracket
			if grouped, ok := patterns[len(patterns)-1].(*ast.GroupedPatternNode); ok {
				cmdArg.NodeType = BracketsMatchCmdNodeType
				cmdArg.Side = RightMatchCmdType
				cmd := c.generateMatchCmd(cmdArg)

				patterns = patterns[:len(patterns)-1]
				patternHoles = append(patternHoles, patternHole{
					patterns: grouped.Patterns,
					borders:  [][]int{{nextBorder, nextBorder + 1}},
				})
				borders = append([][]int{{left, nextBorder + 1}}, borders...)
				cmds = append(cmds, cmd)
				nextBorder += 2
				continue
			}

			// TODO: check var left

			isVar := false
			var varNode *ast.VarPatternNode

			if tmp, ok := patterns[0].(*ast.VarPatternNode); ok {
				isVar = true
				cmdArg.Side = LeftMatchCmdType
				varNode = tmp
			} else if tmp, ok := patterns[len(patterns)-1].(*ast.VarPatternNode); ok {
				isVar = true
				cmdArg.Side = RightMatchCmdType
				varNode = tmp
			}

			if isVar {

				strType := ""
				switch varNode.Type {
				case ast.ExprVarType:
					strType = "e"
				case ast.SymbolVarType:
					strType = "s"
				case ast.TermVarType:
					strType = "t"
				}

				ident := fmt.Sprintf("%s.%s", strType, varNode.Name)
				// check repeated var
				if varIdxs, ok := compiledSentence.VarsToIdxs[ident]; ok {

					// TODO: check repeated svar
					cmdArg.Value = fmt.Sprintf("p[%d]", (varIdxs[0][0]))

					switch varNode.Type {
					case ast.SymbolVarType:
						cmdArg.NodeType = RepeatedSymbolVarMatchCmdNodeType
						compiledSentence.VarsToIdxs[ident] = append(
							compiledSentence.VarsToIdxs[ident],
							[]int{nextBorder},
						)
						nextBorder += 1
					case ast.TermVarType:
						cmdArg.NodeType = RepeatedTermVarMatchCmdNodeType

						compiledSentence.VarsToIdxs[ident] = append(
							compiledSentence.VarsToIdxs[ident],
							[]int{nextBorder, nextBorder + 1},
						)
						nextBorder += 2
					}
					cmd := c.generateMatchCmd(cmdArg)
					cmds = append(cmds, cmd)
					continue
				} else {
					switch varNode.Type {
					case ast.SymbolVarType:
						cmdArg.NodeType = SymbolVarMatchCmdNodeType
						nextBorder += 1
					case ast.TermVarType:
						cmdArg.NodeType = TermVarMatchCmdNodeType
						nextBorder += 2
					}
					cmd := c.generateMatchCmd(cmdArg)
					cmds = append(cmds, cmd)
					continue
				}
			}

			// TODO: check repeated var right

			// TODO: check close evar
		}

	}

	compiledSentence.VarsArrSize = nextBorder
	compiledSentence.Commands = cmds
	return compiledSentence
}

func (c *Compiler) generateMatchCmd(arg MatchCommandArg) string {
	buff := bytes.Buffer{}
	c.compiledMatchCmdTmpl.Execute(&buff, arg)

	return buff.String()
}
