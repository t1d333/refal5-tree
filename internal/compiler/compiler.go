package compiler

import (
	// "bytes"
	"fmt"
	"os"
	"path/filepath"
	"text/template"

	"github.com/t1d333/refal5-tree/internal/ast"
	"github.com/t1d333/refal5-tree/internal/parser"
)

// Templates

const (
	mainFileTmplString = `
package main

import (
	"github.com/t1d333/refal5-tree/pkg/runtime"
)

// Autogenerated functions
{{- range .Functions }}
	 {{ template "r5t-func" . }}
{{- end }}

// Rope with view field
var viewField *runtime.Rope

func main() {
	// viewField = runtime.InitViewField()
	// start main loop 
}`

	compiledFunctionTmplString = `
func r5t{{.Name}}_ (arg *runtime.Rope) {
	{{ range .Body }}
		{{ template "r5t-sentence" . }}
	{{ end }}
  panic("Reognition failed")
}`

	compiledSentenceTmplString = `
  for i := 0; i < 1; i++ {
{{- range $name, $idxs := .VarsToIdxs }}
    /* {{ $name }}: {{- range $place := $idxs }} {{ index $place 0}} {{- end }} */
{{- end }}
    var p []int = make([]int, {{ .VarsArrSize }})
		p[0] = 1
		p[1] = arg.Len() - 1
    return;
  }`
)

type CompiledProgram struct {
	Functions []CompiledFunction
}

type CompiledFunction struct {
	Name  string
	Body  []CompiledSentence
	Entry bool
}

type CompiledSentence struct {
	VarsArrSize int
	VarsToIdxs  map[string][][]int
}

type Compiler struct {
	parser               parser.Refal5Parser
	compiledProgramTmpl  *template.Template
	compiledFunctionTmpl *template.Template
	compiledSentenceTmpl *template.Template
}

func NewRefal5Compiler() *Compiler {
	mainTmpl, _ := template.New("r5t-main").Parse(mainFileTmplString)
	funcTmpl := template.Must(mainTmpl.New("r5t-func").Parse(compiledFunctionTmplString))
	sentenceTmpl := template.Must(funcTmpl.New("r5t-sentence").Parse(compiledSentenceTmplString))

	compiler := &Compiler{
		parser:               parser.NewTreeSitterRefal5Parser(),
		compiledSentenceTmpl: sentenceTmpl,
		compiledProgramTmpl:  mainTmpl,
		compiledFunctionTmpl: funcTmpl,
	}

	return compiler
}

func (c *Compiler) Compile(files []string, options CompilerOptions) {
	sources := [][]byte{}
	trees := []*ast.AST{}
	for _, file := range files {
		code, err := c.readFile(file)
		if err != nil {
			// TODO: wrap error
			return
		}

		sources = append(sources, code)

		for _, source := range sources {
			ast, _ := c.parser.Parse(source)
			trees = append(trees, ast)
		}

		c.Generate(trees)
	}
}

func (c *Compiler) readFile(path string) ([]byte, error) {
	file, err := os.ReadFile(filepath.Clean(path))
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", path, err)
	}

	return file, nil
}

func (c *Compiler) Generate(trees []*ast.AST) (string, error) {
	// TODO: find Go function and generate code for GO
	// TODO: generate code for another functions

	// Templates
	functions := []CompiledFunction{}

	for _, tree := range trees {
		for _, function := range tree.Functions {

			generatedBody, err := c.GenerateFunctionBodyCode(function)
			if err != nil {
				return "", fmt.Errorf(
					"failed to generate code for function %s: %w",
					function.Name,
					err,
				)
			}

			compiled := CompiledFunction{
				Name:  function.Name,
				Body:  generatedBody,
				Entry: function.Entry,
			}

			functions = append(functions, compiled)
			// compiledFuncTmpl.Execute(&buff, function)
			// for _, sentence := range function.Body {
			// }

		}

		c.compiledProgramTmpl.Execute(os.Stdout,
			CompiledProgram{
				Functions: functions,
			},
		)
	}

	// mainTmpl.Execute(os.Stdout, compiledProgram{Functions: generatedFunctions})
	return "", nil
}

func (c *Compiler) GenerateFunctionBodyCode(f *ast.FunctionNode) ([]CompiledSentence, error) {
	body := []CompiledSentence{}

	for _, sentence := range f.Body {
		// body = append(body, CompiledSentence{Value: fmt.Sprintf("  //Sentence #%d", i)})
		compiledSentence := c.GenerateSentence(sentence)

		body = append(body, compiledSentence)
	}

	return body, nil
}

func (c *Compiler) GenerateSentence(sentence *ast.SentenceNode) CompiledSentence {
	lhsPatterns := []ast.PatternNode{}

	for _, pattern := range sentence.Lhs {
		lhsPatterns = append(lhsPatterns, pattern)
	}
	compiledSentence := CompiledSentence{
		VarsArrSize: 0,
		VarsToIdxs:  map[string][][]int{},
	}

	idx := 2

	for len(lhsPatterns) > 0 {
		pattern := lhsPatterns[0]
		lhsPatterns = lhsPatterns[1:]
		switch pattern.GetPatternType() {
		case ast.CharactersPatternType:
		case ast.GroupedPatternType:
			grouped := pattern.(*ast.GroupedPatternNode)
			for _, tmp := range grouped.Patterns {
				lhsPatterns = append([]ast.PatternNode{tmp}, lhsPatterns...)
			}
		case ast.NumberPatternType:
		case ast.StringPatternType:
		case ast.VarPatternType:
			varPattern, _ := pattern.(*ast.VarPatternNode)
			idxs := []int{}
			strType := ""
			switch varPattern.Type {
			case ast.ExprVarType:
				idxs = append(idxs, idx, idx+1)
				strType = "e"
				idx += 2
			case ast.SymbolVarType:
				idxs = append(idxs, idx)
				idx += 1
				strType = "s"
			case ast.TermVarType:
				idxs = append(idxs, idx, idx+1)
				idx += 2
				strType = "t"
			}

			ident := fmt.Sprintf("%s.%s", strType, varPattern.Name)
			if _, ok := compiledSentence.VarsToIdxs[ident]; ok {
				compiledSentence.VarsToIdxs[ident] = append(
					compiledSentence.VarsToIdxs[ident],
					idxs,
				)
			} else {
				compiledSentence.VarsToIdxs[ident] = [][]int{idxs}
			}

		case ast.WordPatternType:
		default:
			panic("unexpected ast.PatternType")
		}
	}

	compiledSentence.VarsArrSize = idx

	return compiledSentence
}
