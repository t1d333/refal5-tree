package compiler

import (
	// "bytes"
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"text/template"

	"github.com/t1d333/refal5-tree/internal/ast"
	"github.com/t1d333/refal5-tree/internal/parser"
)

// Templates

const (
	mainFileTmplString = `
package main

import (
	"github.com/t1d333/refal5-tree/pkg/runtime"
)

// Autogenerated functions
{{- range .Functions }}
	 {{ template "r5t-func" . }}
{{- end }}

// Rope with view field
var viewField *runtime.Rope

func main() {
	viewField = runtime.InitViewField()
	runtime.StartMainLoop(viewField)
}`

	compiledFunctionTmplString = `
func r5t{{.Name}}_ (arg *runtime.Rope) {
	{{ range .Body }}
		{{ template "r5t-sentence" . }}
	{{ end }}
  panic("Recognition failed")
}`

	compiledSentenceTmplString = `
  for i := 0; i < 1; i++ {
{{- range $name, $idxs := .VarsToIdxs }}
    /* {{ $name }}: {{- range $place := $idxs }} {{ index $place 0}} {{- end }} */
{{- end }}
    var p []int = make([]int, {{ .VarsArrSize }})
		p[0] = 1
		p[1] = arg.Len() - 1

{{- range $i, $cmd := .Commands}}
    {{ $cmd }}
{{- end}}
    return;
  }`

	elementaryMatchCommandTmplString = `
if (!runtime.R5t{{.NodeType}}{{.Side}}({{.Idx}}, {{.LeftBorder}}, {{.RightBorder}}, {{.Value}}, arg, p)) {
	continue
}

`
)

type MatchCmdSideType string

const (
	LeftMatchCmdType  MatchCmdSideType = "Left"
	RightMatchCmdType MatchCmdSideType = "Right"
)

type MatchCmdNodeType string

const (
	CharMatchCmdNodeType              MatchCmdNodeType = "Char"
	BracketsMatchCmdNodeType          MatchCmdNodeType = "Brackets"
	NumberMatchCmdNodeType            MatchCmdNodeType = "Number"
	FunctionMatchCmdNodeType          MatchCmdNodeType = "Function"
	SymbolVarMatchCmdNodeType         MatchCmdNodeType = "SymbolVar"
	TermVarMatchCmdNodeType           MatchCmdNodeType = "TermVar"
	RepeatedSymbolVarMatchCmdNodeType MatchCmdNodeType = "RepeatedSymbolVar"
	RepeatedTermVarMatchCmdNodeType   MatchCmdNodeType = "RepeatedTermVar"
)

type MatchCommandArg struct {
	NodeType    MatchCmdNodeType
	Side        MatchCmdSideType
	Idx         int
	LeftBorder  int
	RightBorder int
	Value       string
}

type CompiledProgram struct {
	Functions []CompiledFunction
}

type CompiledFunction struct {
	Name  string
	Body  []CompiledSentence
	Entry bool
}

type CompiledSentence struct {
	VarsArrSize int
	VarsToIdxs  map[string][][]int
	Commands    []string
}

type Compiler struct {
	parser               parser.Refal5Parser
	compiledProgramTmpl  *template.Template
	compiledFunctionTmpl *template.Template
	compiledSentenceTmpl *template.Template
	compiledMatchCmdTmpl *template.Template
}

func NewRefal5Compiler() *Compiler {
	mainTmpl, _ := template.New("r5t-main").Parse(mainFileTmplString)
	funcTmpl := template.Must(mainTmpl.New("r5t-func").Parse(compiledFunctionTmplString))
	sentenceTmpl := template.Must(funcTmpl.New("r5t-sentence").Parse(compiledSentenceTmplString))
	matchCmdTmpl, _ := template.New("r5t-match-cmd").Parse(elementaryMatchCommandTmplString)

	compiler := &Compiler{
		parser:               parser.NewTreeSitterRefal5Parser(),
		compiledSentenceTmpl: sentenceTmpl,
		compiledProgramTmpl:  mainTmpl,
		compiledFunctionTmpl: funcTmpl,
		compiledMatchCmdTmpl: matchCmdTmpl,
	}

	return compiler
}

func (c *Compiler) Compile(files []string, options CompilerOptions) {
	sources := [][]byte{}
	trees := []*ast.AST{}
	for _, file := range files {
		code, err := c.readFile(file)
		if err != nil {
			// TODO: wrap error
			return
		}

		sources = append(sources, code)

		for _, source := range sources {
			ast, _ := c.parser.Parse(source)
			trees = append(trees, ast)
		}

		c.Generate(trees)
	}
}

func (c *Compiler) readFile(path string) ([]byte, error) {
	file, err := os.ReadFile(filepath.Clean(path))
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", path, err)
	}

	return file, nil
}

func (c *Compiler) Generate(trees []*ast.AST) (string, error) {
	// TODO: find Go function and generate code for GO
	// TODO: generate code for another functions

	// Templates
	functions := []CompiledFunction{}

	for _, tree := range trees {
		for _, function := range tree.Functions {

			generatedBody, err := c.GenerateFunctionBodyCode(function)
			if err != nil {
				return "", fmt.Errorf(
					"failed to generate code for function %s: %w",
					function.Name,
					err,
				)
			}

			compiled := CompiledFunction{
				Name:  function.Name,
				Body:  generatedBody,
				Entry: function.Entry,
			}

			functions = append(functions, compiled)
			// compiledFuncTmpl.Execute(&buff, function)
			// for _, sentence := range function.Body {
			// }

		}

		c.compiledProgramTmpl.Execute(os.Stdout,
			CompiledProgram{
				Functions: functions,
			},
		)
	}

	// mainTmpl.Execute(os.Stdout, compiledProgram{Functions: generatedFunctions})
	return "", nil
}

func (c *Compiler) GenerateFunctionBodyCode(f *ast.FunctionNode) ([]CompiledSentence, error) {
	body := []CompiledSentence{}

	for _, sentence := range f.Body {
		// body = append(body, CompiledSentence{Value: fmt.Sprintf("  //Sentence #%d", i)})
		compiledSentence := c.GenerateSentence(sentence)

		body = append(body, compiledSentence)
	}

	return body, nil
}

type patternHole struct {
	patterns []ast.PatternNode
	borders  [][]int
}

func (c *Compiler) GenerateSentence(sentence *ast.SentenceNode) CompiledSentence {
	lhsPatterns := []ast.PatternNode{}

	for _, pattern := range sentence.Lhs {
		lhsPatterns = append(lhsPatterns, pattern)
	}

	compiledSentence := CompiledSentence{
		VarsArrSize: 0,
		VarsToIdxs:  map[string][][]int{},
		Commands:    []string{},
	}

	idx := 2

	for len(lhsPatterns) > 0 {
		pattern := lhsPatterns[0]
		lhsPatterns = lhsPatterns[1:]
		switch pattern.GetPatternType() {
		case ast.CharactersPatternType:
		case ast.GroupedPatternType:
			grouped := pattern.(*ast.GroupedPatternNode)
			for _, tmp := range grouped.Patterns {
				lhsPatterns = append([]ast.PatternNode{tmp}, lhsPatterns...)
			}
		case ast.NumberPatternType:
		case ast.StringPatternType:
		case ast.VarPatternType:
			varPattern, _ := pattern.(*ast.VarPatternNode)
			idxs := []int{}
			strType := ""
			switch varPattern.Type {
			case ast.ExprVarType:
				idxs = append(idxs, idx, idx+1)
				strType = "e"
				idx += 2
			case ast.SymbolVarType:
				idxs = append(idxs, idx)
				idx += 1
				strType = "s"
			case ast.TermVarType:
				idxs = append(idxs, idx, idx+1)
				idx += 2
				strType = "t"
			}

			ident := fmt.Sprintf("%s.%s", strType, varPattern.Name)
			if _, ok := compiledSentence.VarsToIdxs[ident]; ok {
				compiledSentence.VarsToIdxs[ident] = append(
					compiledSentence.VarsToIdxs[ident],
					idxs,
				)
			} else {
				compiledSentence.VarsToIdxs[ident] = [][]int{idxs}
			}

		case ast.WordPatternType:
		default:
			panic("unexpected ast.PatternType")
		}
	}

	compiledSentence.VarsArrSize = idx

	patternHoles := []patternHole{{
		patterns: sentence.Lhs,
		borders:  [][]int{{0, 1}},
	}}

	cmds := []string{}
	nextBorder := 3

	for len(patternHoles) > 0 {
		hole := patternHoles[0]
		patternHoles = patternHoles[1:]
		patterns := hole.patterns

		borders := hole.borders

		for len(borders) > 0 {

			left, right := borders[0][0], borders[0][1]
			borders = borders[1:]

			if len(patterns) == 0 {
				fmt.Println("Empty hole", left, right, hole)
				break
			}

			// TODO: check if left hole is symbol
			if charNode, ok := patterns[0].(*ast.CharactersPatternNode); ok {
				cmd := c.generateMatchCmd(MatchCommandArg{
					NodeType:    CharMatchCmdNodeType,
					Side:        LeftMatchCmdType,
					Idx:         nextBorder,
					LeftBorder:  left,
					RightBorder: right,
					Value:       fmt.Sprintf("'%c'", charNode.Value[0]),
				})

				charNode.Value = charNode.Value[1:]

				if len(charNode.Value) == 0 {
					patterns = patterns[1:]
				}

				borders = append([][]int{{nextBorder, right}}, borders...)
				cmds = append(cmds, cmd)
				nextBorder += 1
				continue
			}

			// TODO: check if right hole is symbol
			if charNode, ok := patterns[len(patterns)-1].(*ast.CharactersPatternNode); ok {
				cmd := c.generateMatchCmd(MatchCommandArg{
					NodeType:    CharMatchCmdNodeType,
					Side:        RightMatchCmdType,
					Idx:         nextBorder,
					LeftBorder:  left,
					RightBorder: right,
					Value:       fmt.Sprintf("'%c'", charNode.Value[0]),
				})

				charNode.Value = charNode.Value[1:]

				if len(charNode.Value) == 0 {
					patterns = patterns[:len(patterns)-1]
				}

				borders = append([][]int{{left, nextBorder}}, borders...)
				cmds = append(cmds, cmd)
				nextBorder += 1
				continue
			}

			// TODO: check if left hole is number
			if numberNode, ok := patterns[0].(*ast.NumberPatternNode); ok {
				cmd := c.generateMatchCmd(MatchCommandArg{
					NodeType:    NumberMatchCmdNodeType,
					Side:        LeftMatchCmdType,
					Idx:         nextBorder,
					LeftBorder:  left,
					RightBorder: right,
					Value:       fmt.Sprintf("%d", numberNode.Value),
				})

				patterns = patterns[1:]
				borders = append([][]int{{nextBorder, right}}, borders...)
				cmds = append(cmds, cmd)
				nextBorder += 1
				continue
			}

			// TODO: check if right hole is symbol
			if numberNode, ok := patterns[len(patterns)-1].(*ast.NumberPatternNode); ok {
				cmd := c.generateMatchCmd(MatchCommandArg{
					NodeType:    CharMatchCmdNodeType,
					Side:        RightMatchCmdType,
					Idx:         nextBorder,
					LeftBorder:  left,
					RightBorder: right,
					Value:       fmt.Sprintf("%d", numberNode.Value),
				})

				patterns = patterns[:len(patterns)-1]
				borders = append([][]int{{left, nextBorder}}, borders...)
				cmds = append(cmds, cmd)
				nextBorder += 1
				continue
			}

			// TODO: check if left hole is bracket
			if grouped, ok := patterns[0].(*ast.GroupedPatternNode); ok {
				cmd := c.generateMatchCmd(MatchCommandArg{
					NodeType:    BracketsMatchCmdNodeType,
					Side:        LeftMatchCmdType,
					Idx:         nextBorder,
					LeftBorder:  left,
					RightBorder: right,
					Value:       "",
				})

				patterns = patterns[1:]
				patternHoles = append(patternHoles, patternHole{
					patterns: grouped.Patterns,
					borders:  [][]int{{nextBorder, nextBorder + 1}},
				})
				borders = append([][]int{{nextBorder + 1, right}}, borders...)
				cmds = append(cmds, cmd)
				nextBorder += 2
				continue
			}

			// TODO: check if right hole is bracket
			if grouped, ok := patterns[len(patterns)-1].(*ast.GroupedPatternNode); ok {
				cmd := c.generateMatchCmd(MatchCommandArg{
					NodeType:    BracketsMatchCmdNodeType,
					Side:        RightMatchCmdType,
					Idx:         nextBorder,
					LeftBorder:  left,
					RightBorder: right,
					Value:       "",
				})

				patterns = patterns[:len(patterns)-1]
				patternHoles = append(patternHoles, patternHole{
					patterns: grouped.Patterns,
					borders:  [][]int{{nextBorder, nextBorder + 1}},
				})
				borders = append([][]int{{left, nextBorder + 1}}, borders...)
				cmds = append(cmds, cmd)
				nextBorder += 2
				continue
			}

			// TODO: check empty hole

			// TODO: check repeated var left

			// TODO: check repeated var right

			// TODO: check close evar

			// TODO: check new s ant t vars

		}
	}

	compiledSentence.Commands = cmds
	return compiledSentence
}

func (c *Compiler) generateMatchCmd(arg MatchCommandArg) string {
	buff := bytes.Buffer{}
	c.compiledMatchCmdTmpl.Execute(&buff, arg)

	return buff.String()
}
