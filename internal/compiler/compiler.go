package compiler

import (
	// "bytes"
	"fmt"
	"os"
	"path/filepath"
	"text/template"

	"github.com/t1d333/refal5-tree/internal/ast"
	"github.com/t1d333/refal5-tree/internal/parser"
)

// Templates

const (
	mainFileTmplString = `
package main

import (
	"github.com/t1d333/refal5-tree/pkg/runtime"
)

// Autogenerated functions
{{- range .Functions }}
	 {{ template "r5t-func" . }}
{{- end }}

// Rope with view field
var viewField *runtime.Rope

func main() {
	// init Go func call
	// start main loop 
	viewField = runtime.InitViewField()
}`

	compiledFunctionTmplString = `
func r5t{{.Name}}_ (r *runtime.Rope) {
	{{ range .Body }}
		{{ template "r5t-sentence" . }}
	{{ end }}
	panic("Reognition failed")
}`

	compiledSentenceTmplString = `
for i := 0; i < 1; i++ {
{{- range $name, $idxs := .VarsToIdxs }}
	{{- range $place := $idxs }}
	/* {{ $name }}: {{ index $place 0}} */
	{{- end }}
{{- end }}
	var p [{{ .VarsCount }}]*runtime.R5Node
	print(p)
	return;
}`
)

type CompiledProgram struct {
	Functions []CompiledFunction
}

type CompiledFunction struct {
	Name  string
	Body  []CompiledSentence
	Entry bool
}

type CompiledSentence struct {
	VarsCount  int
	VarsToIdxs map[string][][]int
}

type Compiler struct {
	parser               parser.Refal5Parser
	compiledProgramTmpl  *template.Template
	compiledFunctionTmpl *template.Template
	compiledSentenceTmpl *template.Template
}

func NewRefal5Compiler() *Compiler {
	mainTmpl, _ := template.New("r5t-main").Parse(mainFileTmplString)
	funcTmpl := template.Must(mainTmpl.New("r5t-func").Parse(compiledFunctionTmplString))
	sentenceTmpl := template.Must(funcTmpl.New("r5t-sentence").Parse(compiledSentenceTmplString))

	compiler := &Compiler{
		parser:               parser.NewTreeSitterRefal5Parser(),
		compiledSentenceTmpl: sentenceTmpl,
		compiledProgramTmpl:  mainTmpl,
		compiledFunctionTmpl: funcTmpl,
	}

	return compiler
}

func (c *Compiler) Compile(files []string, options CompilerOptions) {
	sources := [][]byte{}
	trees := []*ast.AST{}
	for _, file := range files {
		code, err := c.readFile(file)
		if err != nil {
			// TODO: wrap error
			return
		}

		sources = append(sources, code)

		for _, source := range sources {
			ast, _ := c.parser.Parse(source)
			trees = append(trees, ast)
		}

		c.Generate(trees)
	}
}

func (c *Compiler) readFile(path string) ([]byte, error) {
	file, err := os.ReadFile(filepath.Clean(path))
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", path, err)
	}

	return file, nil
}

func (c *Compiler) Generate(trees []*ast.AST) (string, error) {
	// TODO: find Go function and generate code for GO
	// TODO: generate code for another functions

	// Templates
	functions := []CompiledFunction{}

	for _, tree := range trees {
		for _, function := range tree.Functions {

			generatedBody, err := c.GenerateFunctionBodyCode(function)
			if err != nil {
				return "", fmt.Errorf(
					"failed to generate code for function %s: %w",
					function.Name,
					err,
				)
			}

			compiled := CompiledFunction{
				Name:  function.Name,
				Body:  generatedBody,
				Entry: function.Entry,
			}

			functions = append(functions, compiled)
			// compiledFuncTmpl.Execute(&buff, function)
			// for _, sentence := range function.Body {
			// }

		}

		c.compiledProgramTmpl.Execute(os.Stdout,
			CompiledProgram{
				Functions: functions,
			},
		)
	}

	// mainTmpl.Execute(os.Stdout, compiledProgram{Functions: generatedFunctions})
	return "", nil
}

func (c *Compiler) GenerateFunctionBodyCode(f *ast.FunctionNode) ([]CompiledSentence, error) {
	body := []CompiledSentence{}

	for _, sentence := range f.Body {
		// body = append(body, CompiledSentence{Value: fmt.Sprintf("  //Sentence #%d", i)})
		compiledSentence := CompiledSentence{
			VarsCount:  0,
			VarsToIdxs: map[string][][]int{},
		}

		// sentence.Lhs.
		varToIdx := map[string][][]int{}
		idx := 0
		for _, pattern := range sentence.Lhs {
			switch pattern.GetPatternType() {
			case ast.CharactersPatternType:
			case ast.GroupedPatternType:
			case ast.NumberPatternType:
			case ast.StringPatternType:
			case ast.VarPatternType:
				varPattern, _ := pattern.(*ast.VarPatternNode)
				idxs := []int{}
				strType := ""
				switch varPattern.Type {
				case ast.ExprVarType:
					idxs = append(idxs, idx, idx+1)
					strType = "e"
					idx += 2
				case ast.SymbolVarType:
					idxs = append(idxs, idx)
					idx += 1
					strType = "s"
				case ast.TermVarType:
					idxs = append(idxs, idx, idx+1)
					idx += 2
					strType = "t"
					// default:
					// panic(fmt.Sprintf("unexpected ast.VaribaleType: %#v", varPattern.Type))
				}

				ident := fmt.Sprintf("%s.%s", strType, varPattern.Name)
				if _, ok := compiledSentence.VarsToIdxs[ident]; ok {
					compiledSentence.VarsToIdxs[ident] = append(varToIdx[ident], idxs)
				} else {
					compiledSentence.VarsToIdxs[ident] = [][]int{idxs}
				}
			case ast.WordPatternType:
			default:
				panic("unexpected ast.PatternType")
			}
		}

		compiledSentence.VarsCount = idx
		body = append(body, compiledSentence)
	}

	return body, nil
}
